# クライアントサーバ(C/S)モデル
- 応用層のプログラム．
- ネットワーク利用形態モデルの1つ．
  - サーバは，サービスを提供する．
    - Well Known Portで受動オープンする．
    - OSの起動時に，自動的に起動されるプロセス(UNIXではデーモン，Windowsではサービス)である．
  - クライアントは，サービスを要求する．
    - Well Known Portに対して能動オープンする．
    - WindowsではMAPI等のAPIも使われているが，ソケットインターフェースが一般に利用されている．
- 1台のホストがあるサービスではサーバ，あるサービスではクライアントとなれる．
  - クライアントとサーバは対等な関係にある．
- 別のサーバに要求を転送して，処理させることも可能である．

# サーバの形態
- 反復サーバ
  - サーバプロセスが自分で要求を処理する．
  - 処理が終わるまでは次の要求を処理できない．処理が短時間で終わる場合に有効である．
- 平行サーバ
  - 子プロセスを生成して子プロセスに要求を処理させる．
  - すぐ次の要求を処理できる．
  - 多くのメモリを必要とする欠点がある．

# トランスポート層「UDP」
- 信頼性のないコネクションレス型プロトコル
  - オーバへっδーが小さい．
  - 処理効率が高く，高速である．
- UDPを使う応用層の例
  - DNS(Domain Name System)
    - 512オクテットまではUDPを使う．
  - NFS(Network File System)
    - ファイルシステム自身で信頼性を確保する．
  - 音声，動画，VoIP等のストリームデータ
    - 少し損失しても良いが，揺らぎがある方が問題．

# ソケットインターフェース
- UNIX(Windows)での通信プログラムの基本インターフェース．
- 汎用の通信APIとして設計されている．
  - ネットワークシステムはインターネットに限らない．
  - インターネットが普及した現在では，無駄が多い．
- 応用層の最下部．
- 通信端子(ソケット)を作り，端子間をネットワークで接続する．
- TCPではファイルアクセスと同様に使える．

# トランスポート層「TCP」
- 信頼性のあるコネクション型プロトコル
  - 上位層に対して仮想的な通信路(VC: Virtual Circuit)を提供する．
- 神羅伊勢を提供するための機能
  - 誤り制御(再送制御)
  - 順序制御
  - フロー制御と輻輳制御
- その他の機能
  - 全二重通信
  - バイトストリームサービス

# 通信携帯
- 二重通信
  - 送信も受信もできることを意味する．
- 全二重通信
  - 送信と受信を同時にできる．
  - いつでも送信できる．
  - 例: 電話
- 半二重通信
  - どちらか一方だけが送信できる．
  - 受診中は送信できない．
  - 例: トランシーバ

# バイトストリームサービス
- 受信側は，流れてくるデータの区切りが見えない．
  - 何オクテット受信するか分からない．
  - 受信終了は受信したデータ量が0となることで判断する．
- 送信側も，今出力したデータの塊がそのまま受信側に伝わるか分からない．
  - 100オクテットのデータを送信したからといって受信側にそのまま100オクテットのデータが届くとは限らない．

# TCPセグメント

[RFC 793](https://tools.ietf.org/html/rfc793)

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

# TCPヘッダ(1)
- 送信元ポート番号(16bit)
  - 送信側のポート番号．
- 宛先ポート番号(16bit)
  - 受信側のポート番号．

# TCPヘッダ(2)
- シーケンス番号\[SEQ\](32bit)
  - TCPセグメントのデータ部の1オクテット目の，送信開始からのオフセット(変位)である．
    - 送信側から受信側に通知される．
    - コネクション確立時に，お互いの初期シーケンス番号を交換する．
- 確認応答番号\[ACK\](32bit)
  - ACK-1まで正常に受信したことを受信側から送信側に通知する．
    - ACKは，次に受信を期待するSEQという意味でもある．

# TCPヘッダ(3)
- データオフセット\[OFF\](4bit)
  - 32bit単位で，オプションがなければ5が設定されている．
    - データ部の開始位置を表す．
    - TCPヘッダ長を表している．

# TCPヘッダ(4)
- 制御ビット(6bit)
  - SYN: 同期ビット．コネクションを確立する．
  - FIN: 終了ビット．コネクションを切断する．
  - PSH: プッシュビット．送信バッファがカラになった．

# TCPヘッダ(5)
- ウィンドウサイズ(16bit)
  - 受信側から受信可能なデータ量を送信側に通知する．
  - スライディングウィンドウ制御用である．

# TCPの通信手順(概要)
- コネクション(VC)の確立: (1)
- データの送受信: (2)~(4)
- コネクション(VC)の切断: (5)

# コネクションの確立
- 3ウェイハンドシェークを実施する．
  - クライアントとサーバ間でセグメントを3回交換する．
    - SYNセグメントとACKセグメントを交換する．
    - お互いの初期シーケンス番号を交換する．
- TCPコネクション管理構造体(tcpcb)を確保する．
- 受動オープン(サーバ側実行)
  - クライアントからのコネクション確立要求を待っている状態であること．
- 能動オープン(クライアント側実行)
  - サーバへのコネクション確立要求を実行する．

# コネクションの切断
- 送信するデータがないことを相手に通知する．
  - 先に切断sルウのはクライアントでもサーバでも，どちらでも良い．
  - WWWはサーバから切断する．
- FINセグメントとACKセグメントを交換する．
- ハーフクローズ(一方のみクローズ)機能あり．
  - 相手の送信が終わっても，送信可能である．
- TCPコネクション管理構造体(tcpcb)を解放する．

# 高信頼性通信
- 正常に受信できたことを確認して，データの送受信を行う．
  - シーケンス番号(SEQ)
  - 確認応答番号(ACK)
- 正常に受信できない原因
  - 配送途中での破棄等がある．
    - SWハブやルータにおける受信バッファの溢れ．
    - 通信回線での雑音によるデータ誤り．
- 送信と同時に再送タイマーをスタートする．
  - タイムアウトしたら再送する．
- 再送は最大12回，時間的には標準で約9分．
  - 再送毎にタイムアウト値を，ある一定値(標準で約1分)まで，2倍にする．

# 高効率通信
- 送信を行う美に確認応答を待っていると効率が悪い．
  - LAN内では，確認応答の到着までの延長時間は短いが，インターネットを経由すると遅延時間は長くなる．
- スライディングウィンド制御
  - 受信側が，受信可能なデータ量(ウィンドウサイズ)を送信側に通知する．
  - 送信側はウィンドウサイズまで連続送信可能である．
    - 確認応答を待つ必要はない．
  - 確認応答も，まとめて送信可能である．

# 順序制御
- 送信側の応用プログラムが送った順番通りに，受信側の応用プログラムにデータを渡す．
- 順序が狂う原因
  - 配送途中での破棄等．
  - 異なる経路による配送，追越し．

# クライアントサーバ(C/S)モデル
- 応用層のプログラム
  - ネットワーク利用形態モデルの一つである．
    - Well Known Portで受動オープンする．
    - OSの起動時に，自動的に起動されるプロセス(UNIXではデーモン，Windowsではサービス)である．

# ソケットインターフェース関数
- ソケットインタフェース関数の第1引数は，ソケットディスクリプ多である(例外あり)．
  - `socket()`関数の戻り値がソケットディスクリプ多である．
- ソケットインタフェース関数の戻り値が，負の値であればエラーが発生している(例外あり)．

# ソケット生成関数(socket)
- 第1引数: ネットワークシステムの指定
  - `PF_INET`: IPv4
  - `PF_INET6`: IPv6
  - `PF_UNIX`: UNIX内のプロセス間通信
- 第2引数: ネットワークシステムの指定
  - `SOCK_DGRAM`: UDP
  - `SOCK_STREAM`: TCP
- 第3引数: プロトコルの指定
  - 通信タイプで自動的に設定されるので，普通は0を指定する．
  - プロトコル
    - `IPPROTO_UDP`: UDP
    - `IPPROTO_TCP`: TCP
- 戻り値
  - ソケットディスクリプタ(整数値)
  - -1ならエラー．

# サーバとの接続
- C/Sモデルで，クライアントプログラムは，ネットワーク上にあるサーバPCのサーバプログラムに接続する必要がある．
  - サーバPCの指定には，IPアドレスが使われる．
    - 一般にはDNSにより，ホスト名からIPアドレスに変換する．
  - サーバプログラム(プロセス，デーモン，サービス)の指定には，ポート番号が使われる．
    - 一般的にはWell Known Portが使われる．
- サーバプログラム側にも，クライアントのIPアドレスとポート番号が必要である．
  - サーバは，この情報を使って，クライアントとの通信を行う．

# ソケットアドレス構造体
- ソケットインターフェースでは，ソケットアドレス構造体にIPアドレスとポート番号等を設定し，ソケット関数の引数として使われる．
  - クライアント・サーバのどちらでも使用されている．
  - ネットワークシステムに対応したソケットアドレス構造体が定義されている．
    - IPv6用: `struct sockaddr_in6`
    - IPv4用: `struct sockaddr_in`
  - ソケット関数の引数として指定する場合は，`(struct sockaddr*)`でキャストする．

# IPアドレスの設定
- クライアントでは，サーバのIPアドレスの指定は**必須**である．
- サーバでは，通常IPアドレスを指定しない．

# バイトオーダ
- 複数バイトのデータをメモリに配置する順序．
- ビッグエンディアン
  - 最下位バイト(エンド)を上位アドレスに配置する．
- リトルエンディアン
  - 最下位バイト(エンド)を下位アドレスに配置する．

# バイトオーダ変換関数(マクロ)
- プログラムの移植性を高めるため，常に指定する．
- プロセッサ(ホスト)からネットワーク
  - `net = htonl(host);` long型(IPアドレス)
  - `net = htons(host);` short型(ポート番号)
- ネットワークからプロセッサ
  - `host = ntohl(net);` long型
  - `host = ntohs(net);` short型

# ソケットアドレス構造体との入出力
- 各メンバへの書き込み
  - ネットワークバイトオーダに変換して書き込む．
    - `s->sin_addr = htonl(INADDR_ANY);`
    - `s->sin_port = htons(port);`
- 各メンバからの読み出し
  - ホストバイトオーダに変換して読みだす．
    - `ipaddr = ntohl(s->sin_addr);`
    - `portno = ntohs(s->sin_port);`

# バイトオーダ変換関数の必要性
- 必要がない場合
  - 関数内で変換も行う関数．
    - `inet_pton();`
    - `gethostbyname2();`
    - `getservbyname();`
- 必要がある場合
  - 一般の文字列操作関数の出力．
    - `strtol();`
    - etc

# タイムアウトの実装
- 問題点
  - 送信後，相手から応答がないと永久に停止する．
    - 通信プログラムでは，応答がない場合の対応が必須である．
    - TCPにはタイムアウトの規定があるが，UDPにはない．
- 原因
  - IPアドレスの誤り(ホストが存在しない)．
  - ポート番号の誤り(サーバが起動されていない)．
  - トランスポート層以下の階層での破棄．
- 解決方法
  - タイムアウトを実装する．
  - アラームシグナルと処理関数を設定する．
