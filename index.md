<!--ts-->
   * [クライアントサーバ(C/S)モデル](#クライアントサーバcsモデル)
   * [サーバの形態](#サーバの形態)
   * [トランスポート層「UDP」](#トランスポート層udp)
   * [ソケットインターフェース](#ソケットインターフェース)
   * [トランスポート層「TCP」](#トランスポート層tcp)
   * [通信携帯](#通信携帯)
   * [バイトストリームサービス](#バイトストリームサービス)
   * [TCPセグメント](#tcpセグメント)
   * [TCPヘッダ(1)](#tcpヘッダ1)
   * [TCPヘッダ(2)](#tcpヘッダ2)
   * [TCPヘッダ(3)](#tcpヘッダ3)
   * [TCPヘッダ(4)](#tcpヘッダ4)
   * [TCPヘッダ(5)](#tcpヘッダ5)
   * [TCPの通信手順(概要)](#tcpの通信手順概要)
   * [コネクションの確立](#コネクションの確立)
   * [コネクションの切断](#コネクションの切断)
   * [高信頼性通信](#高信頼性通信)
   * [高効率通信](#高効率通信)
   * [順序制御](#順序制御)
   * [クライアントサーバ(C/S)モデル](#クライアントサーバcsモデル-1)
   * [ソケットインターフェース関数](#ソケットインターフェース関数)
   * [ソケット生成関数(socket)](#ソケット生成関数socket)
   * [サーバとの接続](#サーバとの接続)
   * [ソケットアドレス構造体](#ソケットアドレス構造体)
   * [IPアドレスの設定](#ipアドレスの設定)
   * [バイトオーダ](#バイトオーダ)
   * [バイトオーダ変換関数(マクロ)](#バイトオーダ変換関数マクロ)
   * [ソケットアドレス構造体との入出力](#ソケットアドレス構造体との入出力)
   * [バイトオーダ変換関数の必要性](#バイトオーダ変換関数の必要性)
   * [タイムアウトの実装](#タイムアウトの実装)
   * [まとめ](#まとめ)

<!--te-->
# クライアントサーバ(C/S)モデル
- 応用層のプログラム．
- ネットワーク利用形態モデルの1つ．
  - サーバは，サービスを提供する．
    - Well Known Portで受動オープンする．
    - OSの起動時に，自動的に起動されるプロセス(UNIXではデーモン，Windowsではサービス)である．
  - クライアントは，サービスを要求する．
    - Well Known Portに対して能動オープンする．
    - WindowsではMAPI等のAPIも使われているが，ソケットインターフェースが一般に利用されている．
- 1台のホストがあるサービスではサーバ，あるサービスではクライアントとなれる．
  - クライアントとサーバは対等な関係にある．
- 別のサーバに要求を転送して，処理させることも可能である．

# サーバの形態
- 反復サーバ
  - サーバプロセスが自分で要求を処理する．
  - 処理が終わるまでは次の要求を処理できない．処理が短時間で終わる場合に有効である．
- 平行サーバ
  - 子プロセスを生成して子プロセスに要求を処理させる．
  - すぐ次の要求を処理できる．
  - 多くのメモリを必要とする欠点がある．

# トランスポート層「UDP」
- 信頼性のないコネクションレス型プロトコル
  - オーバヘッドが小さい．
  - 処理効率が高く，高速である．
- UDPを使う応用層の例
  - DNS(Domain Name System)
    - 512オクテットまではUDPを使う．
  - NFS(Network File System)
    - ファイルシステム自身で信頼性を確保する．
  - 音声，動画，VoIP等のストリームデータ
    - 少し損失しても良いが，揺らぎがある方が問題．

# ソケットインターフェース
- UNIX(Windows)での通信プログラムの基本インターフェース．
- 汎用の通信APIとして設計されている．
  - ネットワークシステムはインターネットに限らない．
  - インターネットが普及した現在では，無駄が多い．
- 応用層の最下部．
- 通信端子(ソケット)を作り，端子間をネットワークで接続する．
- TCPではファイルアクセスと同様に使える．

# トランスポート層「TCP」
- 信頼性のあるコネクション型プロトコル
  - 上位層に対して仮想的な通信路(VC: Virtual Circuit)を提供する．
- 信頼性を提供するための機能
  - 誤り制御(再送制御)
  - 順序制御
  - フロー制御と輻輳制御
- その他の機能
  - 全二重通信
  - バイトストリームサービス

# 通信携帯
- 二重通信
  - 送信も受信もできることを意味する．
- 全二重通信
  - 送信と受信を同時にできる．
  - いつでも送信できる．
  - 例: 電話
- 半二重通信
  - どちらか一方だけが送信できる．
  - 受診中は送信できない．
  - 例: トランシーバ

# バイトストリームサービス
- 受信側は，流れてくるデータの区切りが見えない．
  - 何オクテット受信するか分からない．
  - 受信終了は受信したデータ量が0となることで判断する．
- 送信側も，今出力したデータの塊がそのまま受信側に伝わるか分からない．
  - 100オクテットのデータを送信したからといって受信側にそのまま100オクテットのデータが届くとは限らない．

# TCPセグメント

[RFC 793](https://tools.ietf.org/html/rfc793)

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

# TCPヘッダ(1)
- 送信元ポート番号(16bit)
  - 送信側のポート番号．
- 宛先ポート番号(16bit)
  - 受信側のポート番号．

# TCPヘッダ(2)
- シーケンス番号\[SEQ\](32bit)
  - TCPセグメントのデータ部の1オクテット目の，送信開始からのオフセット(変位)である．
    - 送信側から受信側に通知される．
    - コネクション確立時に，お互いの初期シーケンス番号を交換する．
- 確認応答番号\[ACK\](32bit)
  - ACK-1まで正常に受信したことを受信側から送信側に通知する．
    - ACKは，次に受信を期待するSEQという意味でもある．

# TCPヘッダ(3)
- データオフセット\[OFF\](4bit)
  - 32bit単位で，オプションがなければ5が設定されている．
    - データ部の開始位置を表す．
    - TCPヘッダ長を表している．

# TCPヘッダ(4)
- 制御ビット(6bit)
  - SYN: 同期ビット．コネクションを確立する．
  - FIN: 終了ビット．コネクションを切断する．
  - PSH: プッシュビット．送信バッファが空になった．

# TCPヘッダ(5)
- ウィンドウサイズ(16bit)
  - 受信側から受信可能なデータ量を送信側に通知する．
  - スライディングウィンドウ制御用である．

# TCPの通信手順(概要)
- コネクション(VC)の確立: (1)
- データの送受信: (2)~(4)
- コネクション(VC)の切断: (5)

# コネクションの確立
- 3ウェイハンドシェークを実施する．
  - クライアントとサーバ間でセグメントを3回交換する．
    - SYNセグメントとACKセグメントを交換する．
    - お互いの初期シーケンス番号を交換する．
- TCPコネクション管理構造体(tcpcb)を確保する．
- 受動オープン(サーバ側実行)
  - クライアントからのコネクション確立要求を待っている状態であること．
- 能動オープン(クライアント側実行)
  - サーバへのコネクション確立要求を実行する．

# コネクションの切断
- 送信するデータがないことを相手に通知する．
  - 先に切断するのはクライアントでもサーバでも，どちらでも良い．
  - WWWはサーバから切断する．
- FINセグメントとACKセグメントを交換する．
- ハーフクローズ(一方のみクローズする)機能あり．
  - 相手の送信が終わっても，送信可能である．
- TCPコネクション管理構造体(tcpcb)を解放する．

# 高信頼性通信
- 正常に受信できたことを確認して，データの送受信を行う．
  - シーケンス番号(SEQ)
  - 確認応答番号(ACK)
- 正常に受信できない原因
  - 配送途中での破棄等がある．
    - SWハブやルータにおける受信バッファの溢れ．
    - 通信回線での雑音によるデータ誤り．
- 送信と同時に再送タイマーをスタートする．
  - タイムアウトしたら再送する．
- 再送は最大12回，時間的には標準で約9分．
  - 再送毎にタイムアウト値を，ある一定値(標準で約1分)まで，2倍にする．

# 高効率通信
- 送信を行う度に確認応答を待っていると効率が悪い．
  - LAN内では，確認応答の到着までの延長時間は短いが，インターネットを経由すると遅延時間は長くなる．
- スライディングウィンド制御
  - 受信側が，受信可能なデータ量(ウィンドウサイズ)を送信側に通知する．
  - 送信側はウィンドウサイズまで連続送信可能である．
    - 確認応答を待つ必要はない．
  - 確認応答も，まとめて送信可能である．

# 順序制御
- 送信側の応用プログラムが送った順番通りに，受信側の応用プログラムにデータを渡す．
- 順序が狂う原因
  - 配送途中での破棄等．
  - 異なる経路による配送，追越し．

# クライアントサーバ(C/S)モデル
- 応用層のプログラム
  - ネットワーク利用形態モデルの一つである．
    - Well Known Portで受動オープンする．
    - OSの起動時に，自動的に起動されるプロセス(UNIXではデーモン，Windowsではサービス)である．

# ソケットインターフェース関数
- ソケットインタフェース関数の第1引数は，ソケットディスクリプタである(例外あり)．
  - `socket()`関数の戻り値がソケットディスクリプタである．
- ソケットインタフェース関数の戻り値が，負の値であればエラーが発生している(例外あり)．

# ソケット生成関数(socket)
- 第1引数: ネットワークシステムの指定
  - `PF_INET`: IPv4
  - `PF_INET6`: IPv6
  - `PF_UNIX`: UNIX内のプロセス間通信
- 第2引数: ネットワークシステムの指定
  - `SOCK_DGRAM`: UDP
  - `SOCK_STREAM`: TCP
- 第3引数: プロトコルの指定
  - 通信タイプで自動的に設定されるので，普通は0を指定する．
  - プロトコル
    - `IPPROTO_UDP`: UDP
    - `IPPROTO_TCP`: TCP
- 戻り値
  - ソケットディスクリプタ(整数値)
  - -1ならエラー．

# サーバとの接続
- C/Sモデルで，クライアントプログラムは，ネットワーク上にあるサーバPCのサーバプログラムに接続する必要がある．
  - サーバPCの指定には，IPアドレスが使われる．
    - 一般にはDNSにより，ホスト名からIPアドレスに変換する．
  - サーバプログラム(プロセス，デーモン，サービス)の指定には，ポート番号が使われる．
    - 一般的にはWell Known Portが使われる．
- サーバプログラム側にも，クライアントのIPアドレスとポート番号が必要である．
  - サーバは，この情報を使って，クライアントとの通信を行う．

# ソケットアドレス構造体
- ソケットインターフェースでは，ソケットアドレス構造体にIPアドレスとポート番号等を設定し，ソケット関数の引数として使われる．
  - クライアント・サーバのどちらでも使用されている．
  - ネットワークシステムに対応したソケットアドレス構造体が定義されている．
    - IPv6用: `struct sockaddr_in6`
    - IPv4用: `struct sockaddr_in`
  - ソケット関数の引数として指定する場合は，`(struct sockaddr*)`でキャストする．

# IPアドレスの設定
- クライアントでは，サーバのIPアドレスの指定は**必須**である．
- サーバでは，通常IPアドレスを指定しない．

# バイトオーダ
- 複数バイトのデータをメモリに配置する順序．
- ビッグエンディアン
  - 最下位バイト(エンド)を上位アドレスに配置する．
- リトルエンディアン
  - 最下位バイト(エンド)を下位アドレスに配置する．

# バイトオーダ変換関数(マクロ)
- プログラムの移植性を高めるため，常に指定する．
- プロセッサ(ホスト)からネットワーク
  - `net = htonl(host);` long型(IPアドレス)
  - `net = htons(host);` short型(ポート番号)
- ネットワークからプロセッサ
  - `host = ntohl(net);` long型
  - `host = ntohs(net);` short型

# ソケットアドレス構造体との入出力
- 各メンバへの書き込み
  - ネットワークバイトオーダに変換して書き込む．
    - `s->sin_addr = htonl(INADDR_ANY);`
    - `s->sin_port = htons(port);`
- 各メンバからの読み出し
  - ホストバイトオーダに変換して読みだす．
    - `ipaddr = ntohl(s->sin_addr);`
    - `portno = ntohs(s->sin_port);`

# バイトオーダ変換関数の必要性
- 必要がない場合
  - 関数内で変換も行う関数．
    - `inet_pton();`
    - `gethostbyname2();`
    - `getservbyname();`
- 必要がある場合
  - 一般の文字列操作関数の出力．
    - `strtol();`
    - etc

# タイムアウトの実装
- 問題点
  - 送信後，相手から応答がないと永久に停止する．
    - 通信プログラムでは，応答がない場合の対応が必須である．
    - TCPにはタイムアウトの規定があるが，UDPにはない．
- 原因
  - IPアドレスの誤り(ホストが存在しない)．
  - ポート番号の誤り(サーバが起動されていない)．
  - トランスポート層以下の階層での破棄．
- 解決方法
  - タイムアウトを実装する．
  - アラームシグナルと処理関数を設定する．

# まとめ
## C/Sモデル
- 応用層のプログラムで，ネットワーク利用形態の1つ．
- クライアントが何らかのサービスを要求し，サーバは要求されたサービスを提供する．
- サーバはポートを受動オープンし，クライアントは能動オープン．
- サーバとクライアントは対等関係で，あるサービスではクライアントであり，またあるサービスではサーバになる．

## 反復サーバ
- サーバプロセスが自分で要求を処理する．
- 処理終了まで次の要求を処理できない．
- 処理が短時間で終わる場合に有効．

## 並行サーバ
- 子プロセスに処理を任せる．
- 要求を同時に処理できるものの，メモリを多く消費する．

## TCP
- 信頼性の高いコネクション型のプロトコル．
	- 誤り制御
	- 順序制御
	- フロー制御，輻輳制御
- 上位層を提供するための仮想通信路(VC: Virtual Circuit)を提供する．
- 全二重通信，バイトストリームサービスを提供する．

## UDP
- 信頼性のないコネクションレス型のプロトコル．
- トランスポート層に属する．
- オーバヘッドが小さく，高速に動作する．
- DNS(応答の素早さ)
- 音声，動画(多少データが欠落しても問題の無いもの)

## ソケットインターフェイス
- UNIXの通信プログラムでの基本的なインターフェース．
- あたかもファイルのように振る舞う．
	- ファイルアクセス同様に使える．
- 汎用の通信API
- 通信端子(ソケット)を作り，ネットワーク間で接続する．

## 通信形態
- 二重通信
	- 送受信可能．
	- 全二重通信
		- 送受信が同時に可能．
		- 電話
	- 半二重通信
		- 送受信は同時にできず，片方ずつ．
		- トランシーバ

## バイトストリームサービス
- 受信側が流れてくるデータ区切りがわからない．
	- 何オクテット?
	- 受信したデータ量が0となることで判断する．
- 送信側も流したデータが全て伝わっているかわからない．
- パケットを細かく分割し，大きなデータを届ける仕組み．
- フラグで管理．

## TCPヘッダ
- 送信元ポート(16bit)
- 送信先ポート(16bit)
- シーケンス番号(32bit)
	- TCPセグメントのデータ部1オクテット目からのオフセット．
	- コネクション確立時に，互いに交換する値．
- 確認応答番号(32bit)
	- ACK-1まで正常に受信したことを送信側へ通知する．
- データオフセット(4bit)
	- データ部の開始位置．
	- TCPヘッダ長
	- 32bit単位で，オプションがなければ5が設定済み．
- 制御ビット(6bit)
	- SYN: コネクションを確立する．同期ビット．
	- FIN: コネクションを切断する．終了ビット．
	- PSH: 送信バッファが空である．プッシュビット．
- ウィンドウサイズ(16bit)
	- 受信可能なデータ量を送信側に通知する．
	- スライディングウィンドウを制御するもの．

## コネクションの確立と切断
- 3ウェイハンドシェイクの実施．
	- s/c間でSYNとACKとを交換する．
	- tcpdb(TCPコネクション管理構造体)を確保する．
	- 受動オープン
		- サーバ側で，コネクション確立要求を待つ．
	- 能動オープン
		- クライアント側で，コネクション確立要求を行う．
- 送信データがないことを相手に伝える．
	- 切断側はs/cどちらでもよい．
		- wwwはs
	- FINとACKを交換する．
	- ハーフクローズ機能も存在する．
	- tcpdbのリリース．

## 高信頼性通信
- SEQ(シーケンス番号)やACK(確認応答番号)で行う．
- 物理的に電気的なノイズが混ざったりネットワーク機器の故障により正常に受信ができない．
- SWハブや受信バッファのあふれにより受信できない．
- 送信時に最早タイマーをスタートし，タイムアウトしたら最早する．
	- 最早回数は最大12回で，9分程度．
		- 最早毎にタイムアウト値をしきい値1分内で2倍にする．

## 高効率通信
- 確認応答を行う時間がネックになる．
- スライティングウィンドウ制御
	- ウィンドウサイズを送信側に伝える．
	- ウィンドウサイズに従って送信を行い，確認応答を必要としない．
	- 確認応答も同時に送れる．

## 順序制御
- 送信側が送信したデータ順にデータを受け取る．
- 配送途中でのパケット破棄や経路の違いによる順番の変化がある．

## ソケットプログラミング
```
/* ソケット構造体 */
struct sockaddr_in addr;
memset(&addr, 0, sizeof(addr));
/* h(ost) to n(etwork) s(hort-type)
 * バイトオーダ(エンディアン)を変換するマクロ．
 */
addr.sin_port = htons("192.168.x.x");
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = htonl(INADDR_ANY);

/* ソケット生成関数
  * - AF_INET: IPv4
  * - AF_INET6: IPv6
  * - PF_UNIX: UNIX間通信
  * - SOCK_STREAM: TCP
  * - SOCK_DGRAM: UDP
  * 第3引数はプロトコルを指定する．0は自動判別．
  */
int sock = socket(AF_INET, SOCK_STREAM, 0);
/* ソケットのバインディング */
bind(sock, (struct sockaddr *)&addr, sizeof(addr));
...(listen等)
```

- `inet_pton()`
- `gethostbyname2()`
- `getservbyname()`

は関数内でバイトオーダを変換する．

## タイムアウト
- データ送信後，相手からの応答がないと停止する
	- TCPはタイムアウトに関する規定がある．
	- UDPはない．
- 原因
	- IPの誤り．
	- ポートの誤り．
	- 下のインターネットプロトコルスイートでのエラー．
- タイムアウト処理を実装する必要がある．
- アラームシグナルや処理関数を設定する．
